<div class="toggle-wrapper">
  <div class="toggle">
    <button class="toggle-option active" data-value="option1">
      lbs
    </button>
    <button class="toggle-option" data-value="option2">
      kg
    </button>
  </div>
</div>

<div class="table-container">
  <div class="table-scroll">
    <table border="1" id="csvTable"></table>
  </div>
</div>

<style>
.toggle-wrapper {
  display: flex;
  justify-content: right;
  margin: 20px 0;
}

.toggle {
  display: flex;
  background: #eee;
  border-radius: 999px;
  padding: 4px;
  position: relative;
  width: fit-content;
}

.toggle-option {
  border: none;
  background: transparent;
  padding: 5px 10px;
  border-radius: 999px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.95rem;
  color: #555;
  position: relative;
  z-index: 2;
  transition: color 0.2s ease;
}

.toggle-option.active {
  color: #fff;
}

/* Sliding background */
.toggle::before {
  content: "";
  position: absolute;
  top: 4px;
  bottom: 4px;
  left: 4px;
  width: 45%;
  background: rgba(138, 138, 167, 0.733);
  border-radius: 999px;
  transition: transform 0.25s ease;
  z-index: 1;
}

/* When second option is active */
.toggle[data-active="option2"]::before {
  transform: translateX(100%);
}
    
@media (max-width: 768px) {
  #csvTable {
    min-width: 600px;
  }
}

@media (min-width: 1024px) {
  #csvTable th,
  #csvTable td {
    white-space: normal;
  }
}

.table-container {
  width: 100%;
  max-width: 1000px;
  margin: 40px auto;
  padding: 20px;
}

/* Horizontal scroll wrapper */
.table-scroll {
  width: 100%;
  overflow-x: auto;
  -webkit-overflow-scrolling: touch;
}

/* Table styling */
#csvTable {
  width: max-content;
  max-width: 100%;
  border-collapse: collapse;
  table-layout: auto;
  border-radius: 8px;
  box-shadow: 0 4px 10px rgba(0,0,0,0.1);
}

#csvTable th,
#csvTable td {
  border: 1px solid #ddd;
  padding: 10px 14px;
  text-align: left;
  white-space: nowrap;
}

/* Sortable header styles */
#csvTable th {
  font-weight: bold;
  cursor: pointer;
  user-select: none;
  position: relative;
}

#csvTable th::after {
  content: " â†•";
  font-size: 0.75em;
  opacity: 0.6;
}

#csvTable th.sort-asc::after {
  content: " â†‘";
}

#csvTable th.sort-desc::after {
  content: " â†“";
}
</style>

<script>
const toggle = document.querySelector(".toggle");
const options = document.querySelectorAll(".toggle-option");

options.forEach(option => {
  option.addEventListener("click", () => {
    options.forEach(o => o.classList.remove("active"));
    option.classList.add("active");

    toggle.setAttribute("data-active", option.dataset.value);

    // ðŸ”¥ Hook into your logic here
    console.log("Selected:", option.dataset.value);
  });
});

const googleSheetsCSV =
  "https://docs.google.com/spreadsheets/d/1mkU6r6YKaEeG1tqgrQfA0SluCg4g_MNeKSGBjmEyFdk/export?format=csv&id=1mkU6r6YKaEeG1tqgrQfA0SluCg4g_MNeKSGBjmEyFdk&gid=0";

fetch(googleSheetsCSV)
  .then(response => response.text())
  .then(data => {
    const rows = data.trim().split("\n");
    const table = document.getElementById("csvTable");

    rows.forEach((row, index) => {
      const tr = document.createElement("tr");

      row.split(",").forEach(cell => {
        const isHeader = index === 0;
        const td = document.createElement(isHeader ? "th" : "td");

        const trimmed = cell.trim();
        const num = parseFloat(trimmed);

        td.textContent =
          !isNaN(num) && trimmed.match(/^-?\d+(\.\d+)?$/)
            ? num.toFixed(2).replace(/\.00$/, "")
            : trimmed;

        tr.appendChild(td);
      });

      table.appendChild(tr);
    });

    makeTableSortable(table);
  })
  .catch(error => console.error("Error loading sheet:", error));

function makeTableSortable(table) {
  const headers = table.querySelectorAll("th");
  const directions = Array(headers.length).fill(true);

  headers.forEach((header, columnIndex) => {
    header.addEventListener("click", () => {
      const rows = Array.from(table.querySelectorAll("tr")).slice(1);
      const ascending = directions[columnIndex] = !directions[columnIndex];

      headers.forEach(h => h.classList.remove("sort-asc", "sort-desc"));
      header.classList.add(ascending ? "sort-asc" : "sort-desc");

      rows.sort((a, b) => {
        const aText = a.children[columnIndex].textContent.trim();
        const bText = b.children[columnIndex].textContent.trim();

        const aNum = parseFloat(aText);
        const bNum = parseFloat(bText);

        if (!isNaN(aNum) && !isNaN(bNum)) {
          return ascending ? aNum - bNum : bNum - aNum;
        }

        return ascending
          ? aText.localeCompare(bText, undefined, { numeric: true })
          : bText.localeCompare(aText, undefined, { numeric: true });
      });

      rows.forEach(row => table.appendChild(row));
    });
  });
}
</script>
